name: Cinepolis Uptime Monitor

on:
  schedule:
    - cron: "* * * * *"   # ‡§π‡§∞ ‡§Æ‡§ø‡§®‡§ü
  workflow_dispatch:

jobs:
  monitor:
    permissions:
      contents: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 20

      - name: Install system dependencies (jq)
        run: |
          # jq ‡§Ö‡§≠‡•Ä ‡§≠‡•Ä Telegram alert logic ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ö‡§æ‡§π‡§ø‡§è
          sudo apt-get update
          sudo apt-get install -y jq

      # dependencies install ‡§ï‡•Ä ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï‡§§‡§æ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à, Puppeteer ‡§π‡§ü‡§æ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à
      
      - name: Check Website Status (Using Node.js HTTPS Module)
        id: check_site
        run: |
          node <<'EOF'
          const https = require('https'); // ‡§ï‡•á‡§µ‡§≤ built-in https ‡§Æ‡•â‡§°‡•ç‡§Ø‡•Ç‡§≤ ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó
          const fs = require('fs');
          const url = require('url'); // URL ‡§ï‡•ã parse ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è

          const STATUS_FILE = 'status.json';
          const TARGET_URL = 'https://www.cinepolis.com/in';
          const MAX_LOG = 1440; // ‡§™‡§ø‡§õ‡§≤‡•á 24 ‡§ò‡§Ç‡§ü‡•á ‡§ï‡•Ä ‡§ú‡§æ‡§Ç‡§ö
          const TIMEOUT_MS = 120000; // 2 ‡§Æ‡§ø‡§®‡§ü ‡§ï‡§æ timeout

          const targetOptions = url.parse(TARGET_URL);

          (async () => {
            let status = 'DOWN';
            let statusCode = 0;
            let responseTime = 0;

            try {
              const startTime = Date.now();
              
              const checkPromise = new Promise((resolve, reject) => {
                const req = https.request({
                  ...targetOptions,
                  method: 'HEAD', // ‡§ï‡•á‡§µ‡§≤ Header fetch ‡§ï‡§∞‡•á‡§Ç, ‡§ú‡•ã ‡§¨‡§π‡•Å‡§§ ‡§§‡•á‡§ú‡§º ‡§π‡•ã‡§§‡§æ ‡§π‡•à
                  headers: {
                    'User-Agent': 'Uptime Monitor Bot/1.0 (via Node.js)',
                    'Accept': '*/*'
                  }
                }, (res) => {
                  responseTime = Date.now() - startTime;
                  const finalStatusCode = res.statusCode;
                  
                  if (finalStatusCode >= 200 && finalStatusCode < 300) {
                    status = 'UP';
                  } else {
                    status = 'DOWN';
                  }
                  statusCode = finalStatusCode;
                  resolve();
                });

                req.on('error', (e) => {
                  responseTime = Date.now() - startTime;
                  console.error('Request Error:', e.message);
                  statusCode = 0;
                  status = 'DOWN';
                  resolve(); 
                });

                req.setTimeout(TIMEOUT_MS, () => {
                  req.destroy();
                  responseTime = Date.now() - startTime;
                  console.error('Request Timeout after:', TIMEOUT_MS, 'ms');
                  statusCode = 0;
                  status = 'DOWN';
                  resolve();
                });
                
                req.end();
              });

              await checkPromise;
              
            } catch (err) {
              // ‡§Ø‡§π ‡§¨‡•ç‡§≤‡•â‡§ï ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§∞‡•Ç‡§™ ‡§∏‡•á ‡§ï‡•á‡§µ‡§≤ Promise/setup errors ‡§ï‡•ã ‡§™‡§ï‡§°‡§º‡•á‡§ó‡§æ
              console.error('General Script Error:', err.message);
              statusCode = 0;
              status = 'DOWN';
            }

            // Read existing status.json safely
            let log = [];
            // ... (log logic is unchanged)
            if (fs.existsSync(STATUS_FILE)) {
              try {
                const content = fs.readFileSync(STATUS_FILE, 'utf8');
                const parsed = JSON.parse(content);
                log = Array.isArray(parsed) ? parsed : [];
              } catch (err) {
                console.error("Invalid JSON, starting fresh log.");
                log = [];
              }
            }

            // Add new entry
            log.push({
              checked_at: new Date().toISOString(),
              status: status,
              status_code: statusCode,
              response_time: responseTime
            });

            // Keep last MAX_LOG entries only
            if (log.length > MAX_LOG) log = log.slice(-MAX_LOG);

            // Calculate uptime %
            const upCount = log.filter(e => e.status === 'UP').length;
            const uptimePercent = ((upCount / log.length) * 100).toFixed(2);

            // Save log
            fs.writeFileSync(STATUS_FILE, JSON.stringify(log, null, 2));

            // Export variables
            fs.appendFileSync(process.env.GITHUB_ENV, `STATUS=${status}\n`);
            fs.appendFileSync(process.env.GITHUB_ENV, `STATUS_CODE=${statusCode}\n`);
            fs.appendFileSync(process.env.GITHUB_ENV, `UPTIME_PERCENT=${uptimePercent}\n`);
            fs.appendFileSync(process.env.GITHUB_ENV, `RESPONSE_TIME=${responseTime}\n`);
          })();
          EOF

      - name: Telegram Alert - DOWN
        if: ${{ env.STATUS != 'UP' }}
        run: |
          TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          MSG="üö® *Website DOWN!* üö®%0A*URL:* https://www.cinepolis.com/in%0A*Status Code:* ${{ env.STATUS_CODE }}%0A*Response Time:* ${{ env.RESPONSE_TIME }}ms%0A*Uptime (24h):* ${{ env.UPTIME_PERCENT }}%"

          curl -s -X POST "https://api.telegram.org/bot$TOKEN/sendMessage" \
            -d chat_id="$CHAT_ID" \
            --data-urlencode "text=$MSG" \
            -d parse_mode="Markdown"

      - name: Telegram Alert - UP (if previously DOWN)
        if: ${{ env.STATUS == 'UP' }}
        run: |
          TOKEN="${{ secrets.TELEGRAM_BOT_TOKEN }}"
          CHAT_ID="${{ secrets.TELEGRAM_CHAT_ID }}"
          PREV_STATUS=$(jq -r '.[-2].status // ""' status.json 2>/dev/null || echo "")
          
          if [ "$PREV_STATUS" != "UP" ]; then
            MSG="‚úÖ *Website is UP!* ‚úÖ%0A*URL:* https://www.cinepolis.com/in%0A*Response Time:* ${{ env.RESPONSE_TIME }}ms%0A*Uptime (24h):* ${{ env.UPTIME_PERCENT }}%"
            curl -s -X POST "https://api.telegram.org/bot$TOKEN/sendMessage" \
              -d chat_id="$CHAT_ID" \
              --data-urlencode "text=$MSG" \
              -d parse_mode="Markdown"
          fi

      - name: Commit status.json
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add status.json
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Uptime Check: ${{ env.STATUS }} (${{ env.STATUS_CODE }})"
            git push "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" HEAD:main
