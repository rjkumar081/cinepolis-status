const puppeteer = require("puppeteer");
const fs = require("fs-extra");
const crypto = require("crypto");
const axios = require("axios");

const URL = "https://cinepolis.com/in";
const STATUS_FILE = "status.json";

// ENV variables from GitHub Secrets
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID;

const API_SECRET_KEY = process.env.API_SECRET_KEY;
const RENDER_WEBHOOK_URL = process.env.RENDER_WEBHOOK_URL;

async function sendTelegram(msg) {
  try {
    await axios.get(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
      params: {
        chat_id: TELEGRAM_CHAT_ID,
        text: msg
      }
    });
    console.log("Telegram alert sent");
  } catch (err) {
    console.log("Telegram Error:", err.message);
  }
}

async function triggerRenderDeploy() {
  try {
    const timestamp = Date.now().toString();

    // Create HMAC signature using your API_SECRET_KEY
    const signature = crypto
      .createHmac("sha256", API_SECRET_KEY)
      .update(timestamp)
      .digest("hex");

    // Hit Render webhook with signature header
    await axios.post(
      RENDER_WEBHOOK_URL,
      {},
      {
        headers: {
          "X-Timestamp": timestamp,
          "X-Signature": signature,
        },
      }
    );

    console.log("Render Deploy Triggered");
  } catch (err) {
    console.log("Render Error:", err.message);
  }
}

async function checkWebsite() {
  let status = "UP";
  let responseTime = 0;
  let realDown = false;

  const start = Date.now();

  try {
    const browser = await puppeteer.launch({
      headless: "new",
      args: ["--no-sandbox"]
    });

    const page = await browser.newPage();

    const response = await page.goto(URL, {
      timeout: 25000,
      waitUntil: "domcontentloaded",
    });

    responseTime = Date.now() - start;

    if (!response || response.status() >= 400) {
      status = "DOWN";
      realDown = true;
    }

    await browser.close();
  } catch (err) {
    status = "DOWN";
    realDown = true;
  }

  return { status, responseTime, realDown };
}

async function saveStatus(finalStatus) {
  await fs.writeJson(STATUS_FILE, finalStatus, { spaces: 2 });
  console.log("Status saved:", finalStatus);
}

async function main() {
  const check = await checkWebsite();

  const finalStatus = {
    status: check.status,
    responseTime: check.responseTime,
    realDown: check.realDown,
    checkedAt: new Date().toISOString(),
  };

  await saveStatus(finalStatus);

  if (check.realDown) {
    await sendTelegram(`❌ Cinepolis DOWN\nResponse: ${check.responseTime}ms`);
    await triggerRenderDeploy();
  } else {
    await sendTelegram(`✅ Cinepolis UP\nResponse: ${check.responseTime}ms`);
  }
}

main();
